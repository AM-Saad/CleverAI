import { NextRequest, NextResponse } from 'next/server';
import { requireRole } from '@/lib/auth';
import prisma from '@/lib/prisma';

const MAX_FAILED_ATTEMPTS = 5;

// POST: Student submits a PIN to unlock a lesson
export async function POST(request: NextRequest) {
  const token = await requireRole(request, ['STUDENT']);
  if (token instanceof NextResponse) return token;
  const { code, lessonId } = await request.json();
  if (!code) {
    return NextResponse.json({ error: 'PIN code is required.' }, { status: 400 });
  }
  // Find the PIN
  const pin = await prisma.pinCode.findUnique({ where: { code } });
  if (!pin) {
    return NextResponse.json({ error: 'Invalid PIN code.' }, { status: 404 });
  }
  if (pin.locked) {
    return NextResponse.json({ error: 'This PIN has been locked due to too many failed attempts or revoked by the teacher.' }, { status: 423 });
  }
  if (pin.used) {
    return NextResponse.json({ error: 'PIN code has already been used.' }, { status: 409 });
  }
  if (pin.expiresAt && new Date(pin.expiresAt) < new Date()) {
    return NextResponse.json({ error: 'PIN code has expired.' }, { status: 410 });
  }
  // Enforce one PIN per student per lesson
  const targetLessonId = pin.lessonId || lessonId;
  if (!targetLessonId) {
    return NextResponse.json({ error: 'Lesson to unlock must be specified for universal PINs.' }, { status: 400 });
  }
  const existingUsedPin = await prisma.pinCode.findFirst({
    where: {
      lessonId: targetLessonId,
      studentId: token.id,
      used: true,
    },
  });
  if (existingUsedPin) {
    return NextResponse.json({ error: 'You have already unlocked this lesson with another PIN.' }, { status: 409 });
  }
  // If PIN is tied to a lesson, only allow unlocking that lesson
  if (pin.lessonId && lessonId && pin.lessonId !== lessonId) {
    await prisma.pinCode.update({
      where: { code },
      data: {
        failedAttempts: { increment: 1 },
        locked: pin.failedAttempts + 1 >= MAX_FAILED_ATTEMPTS,
      },
    });
    return NextResponse.json({ error: 'This PIN is not valid for this lesson.' }, { status: 403 });
  }
  // If pre-assigned, only that student can use
  if (pin.studentId && pin.studentId !== token.id) {
    await prisma.pinCode.update({
      where: { code },
      data: {
        failedAttempts: { increment: 1 },
        locked: pin.failedAttempts + 1 >= MAX_FAILED_ATTEMPTS,
      },
    });
    return NextResponse.json({ error: 'This PIN is not assigned to you.' }, { status: 403 });
  }
  // If not assigned, assign to this student
  const updateData: any = {
    used: true,
    usedAt: new Date(),
    failedAttempts: 0,
    locked: false,
    lessonId: pin.lessonId || lessonId,
  };
  if (!pin.studentId) {
    updateData.studentId = token.id;
  }
  await prisma.pinCode.update({
    where: { code },
    data: updateData,
  });
  return NextResponse.json({ message: 'Lesson unlocked successfully.', lessonId: targetLessonId });
}
