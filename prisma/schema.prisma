datasource db {
    provider = "mongodb"
    url      = env("DATABASE_URL")
}

generator client {
    provider      = "prisma-client-js"
    binaryTargets = ["native", "rhel-openssl-3.0.x"]
}

// =========================
// NEW EDUCATIONAL PLATFORM MODELS
// =========================

model User {
    id                        String                       @id @default(auto()) @map("_id") @db.ObjectId
    name                      String
    email                     String?                      @unique
    password                  String
    phone                     String?                      @unique
    gender                    String?
    role                      UserRole
    createdAt                 DateTime                     @default(now())
    updatedAt                 DateTime                     @updatedAt
    payments                  Payment[]
    folders                   Folder[]                     @relation("UserFolders")
    userTags                  UserTag[]                    @relation("UserTags")
    boardItems                BoardItem[]                  @relation("UserBoardItems")
    boardColumns              BoardColumn[]                @relation("UserBoardColumns")
    subscription              UserSubscription?
    notificationSubscriptions NotificationSubscription[]
    scheduledNotifications    ScheduledNotification[]
    notificationPreferences   UserNotificationPreferences?
    llmGatewayLogs            LlmGatewayLog[]

    // --- Authentication fields ---
    credentials           Json?
    auth_provider         String? @default("credentials")
    account_verified      Boolean @default(false)
    email_verified        Boolean @default(false)
    register_verification String?
    password_verification String?
    passkey_user_id       String? @db.ObjectId
    // --- End authentication fields ---

    // --- Soft delete fields ---
    deletedAt           DateTime?
    scheduledDeletionAt DateTime? // Permanent deletion scheduled for 30 days after soft delete
    // --- End soft delete fields ---
}

enum UserRole {
    USER
}

model Folder {
    id             String          @id @default(auto()) @map("_id") @db.ObjectId
    title          String
    description    String?
    metadata       Json?
    order          Int
    rawText        String?
    questions      Question[]
    flashcards     Flashcard[]
    materials      Material[]
    notes          Note[]
    user           User            @relation("UserFolders", fields: [userId], references: [id], onDelete: Cascade)
    userId         String          @db.ObjectId
    createdAt      DateTime        @default(now())
    updatedAt      DateTime        @updatedAt
    llmModel       String          @default("gpt-3.5")
    llmGatewayLogs LlmGatewayLog[]

    @@unique([userId, order])
}

model Material {
    id         String      @id @default(auto()) @map("_id") @db.ObjectId
    folder     Folder      @relation(fields: [folderId], references: [id], onDelete: Cascade)
    folderId   String      @db.ObjectId
    title      String
    content    String
    type       String? // "video" | "audio" | "text" | "pdf" | etc.
    metadata   Json?
    llmModel   String?     @default("gpt-3.5")
    llmPrompt  String?
    createdAt  DateTime    @default(now())
    updatedAt  DateTime    @updatedAt
    // Relations to generated content
    flashcards Flashcard[]
    questions  Question[]
}

model Note {
    id        String   @id @default(auto()) @map("_id") @db.ObjectId
    folder    Folder   @relation(fields: [folderId], references: [id], onDelete: Cascade)
    folderId  String   @db.ObjectId
    content   String
    tags      String[] @default([])
    order     Int      @default(0)
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    @@index([folderId])
}

model BoardItem {
    id        String       @id @default(auto()) @map("_id") @db.ObjectId
    user      User         @relation("UserBoardItems", fields: [userId], references: [id], onDelete: Cascade)
    userId    String       @db.ObjectId
    column    BoardColumn? @relation("ColumnItems", fields: [columnId], references: [id], onDelete: SetNull)
    columnId  String?      @db.ObjectId
    content   String
    tags      String[]     @default([])
    order     Int          @default(0)
    createdAt DateTime     @default(now())
    updatedAt DateTime     @updatedAt

    @@index([userId, order])
    @@index([columnId, order])
}

model BoardColumn {
    id        String      @id @default(auto()) @map("_id") @db.ObjectId
    user      User        @relation("UserBoardColumns", fields: [userId], references: [id], onDelete: Cascade)
    userId    String      @db.ObjectId
    name      String
    order     Int         @default(0)
    createdAt DateTime    @default(now())
    updatedAt DateTime    @updatedAt
    items     BoardItem[] @relation("ColumnItems")

    @@index([userId, order])
}

model UserTag {
    id        String   @id @default(auto()) @map("_id") @db.ObjectId
    user      User     @relation("UserTags", fields: [userId], references: [id], onDelete: Cascade)
    userId    String   @db.ObjectId
    name      String
    color     String   @default("#3b82f6")
    order     Int      @default(0)
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    @@unique([userId, name])
    @@index([userId, order])
}

model Question {
    id          String       @id @default(auto()) @map("_id") @db.ObjectId
    folder      Folder       @relation(fields: [folderId], references: [id], onDelete: Cascade)
    folderId    String       @db.ObjectId
    // Optional material relation - questions can be generated from specific material
    material    Material?    @relation(fields: [materialId], references: [id], onDelete: Cascade)
    materialId  String?      @db.ObjectId
    type        QuestionType @default(MULTIPLE_CHOICE)
    question    String
    choices     String[] // For MCQ
    answerIndex Int
    // Context Bridge fields
    sourceRef   Json? // { type: 'NOTE'|'PDF', materialId: string, anchor: string }
    status      String       @default("DRAFT") // 'DRAFT' | 'ENROLLED'
    createdAt   DateTime     @default(now())
    updatedAt   DateTime     @updatedAt

    @@index([materialId])
}

model Flashcard {
    id         String    @id @default(auto()) @map("_id") @db.ObjectId
    folder     Folder    @relation(fields: [folderId], references: [id], onDelete: Cascade)
    folderId   String    @db.ObjectId
    // Optional material relation - flashcards can be generated from specific material
    material   Material? @relation(fields: [materialId], references: [id], onDelete: Cascade)
    materialId String?   @db.ObjectId
    front      String
    back       String
    // Context Bridge fields
    sourceRef  Json? // { type: 'NOTE'|'PDF', materialId: string, anchor: string }
    status     String    @default("DRAFT") // 'DRAFT' | 'ENROLLED'
    createdAt  DateTime  @default(now())
    updatedAt  DateTime  @updatedAt

    @@index([materialId])
}

enum QuestionType {
    MULTIPLE_CHOICE
    // Extendable for other types
}

model CardReview {
    id             String    @id @default(auto()) @map("_id") @db.ObjectId
    userId         String // null if anonymous; better when auth lands
    folderId       String
    cardId         String // polymorphic: references Flashcard.id or Material.id
    resourceType   String    @default("flashcard") // will store "material" or "flashcard"
    // Legacy fields for backward compatibility
    flashcardId    String?   @db.ObjectId
    materialId     String?   @db.ObjectId
    // SM-2 lite state:
    intervalDays   Int       @default(0) // I (days)
    easeFactor     Float     @default(2.5) // EF
    repetitions    Int       @default(0) // n
    nextReviewAt   DateTime // scheduled review date
    lastReviewedAt DateTime?
    // analytics
    lastGrade      Int? // 0..5
    streak         Int       @default(0)
    suspended      Boolean   @default(false) // Allow users to pause card reviews

    @@unique([userId, cardId], name: "userId_cardId")
    @@index([userId, nextReviewAt])
    @@index([folderId, nextReviewAt])
}

enum AchievementType {
    DAILY_STREAK
    WEEKLY_STREAK

    CARD_MASTERED
    CARD_REVIEWED
    CARD_REVIEWED_100
}

model XpEvent {
    id        String   @id @default(auto()) @map("_id") @db.ObjectId
    userId    String
    cardId    String?
    source    String // "review" | "enroll"
    xp        Int
    createdAt DateTime @default(now())

    @@index([userId, createdAt])
}

model Achievement {
    id        String          @id @default(auto()) @map("_id") @db.ObjectId
    userId    String
    type      AchievementType
    streak    Int
    createdAt DateTime        @default(now())
    updatedAt DateTime        @updatedAt
}

// Idempotency tracking for grade operations
model GradeRequest {
    id          String   @id @default(auto()) @map("_id") @db.ObjectId
    requestId   String   @unique
    userId      String
    cardId      String
    grade       Int
    processedAt DateTime @default(now())

    @@index([userId, cardId])
    @@index([processedAt])
}

model LlmPrice {
    id                String  @id @default(auto()) @map("_id") @db.ObjectId
    provider          String // "openai" | "google"
    model             String // "gpt-4o" | "gemini-1.5-pro" | ...
    // If you want exact math, store integer minor units (see note below).
    inputPer1kMicros  BigInt // price per 1k input tokens, in micro-dollars (USD * 1_000_000)
    outputPer1kMicros BigInt // price per 1k output tokens, in micro-dollars (USD * 1_000_000)
    isActive          Boolean @default(true)

    @@unique([provider, model], map: "provider_model")
}

model LlmUsage {
    id                        String  @id @default(auto()) @map("_id") @db.ObjectId
    provider                  String // "openai" | "google"
    model                     String
    inputPer1kMicrosSnapshot  BigInt? // snapshot of price used at call time
    outputPer1kMicrosSnapshot BigInt? // snapshot of price used at call time

    promptTokens     Int
    completionTokens Int
    totalTokens      Int

    // Using BigInt for micro-dollars.
    inputUsdMicros  BigInt // micro-dollars
    outputUsdMicros BigInt // micro-dollars
    totalUsdMicros  BigInt // micro-dollars

    requestId    String? // vendor id if available
    status       String  @default("success") // "success" | "error"
    errorCode    String?
    errorMessage String?

    // App context for reporting
    userId   String?
    folderId String?
    feature  String? // "flashcards" | "quiz" | "chat" | etc.

    // Debug/audit
    createdAt    DateTime @default(now())
    rawUsageJson Json?
    meta         Json?

    @@index([provider, model, createdAt])
    @@index([userId, createdAt])
    @@index([folderId, createdAt])
}

model Payment {
    id        String   @id @default(auto()) @map("_id") @db.ObjectId
    user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
    userId    String   @db.ObjectId
    amount    Float
    provider  String
    status    String
    createdAt DateTime @default(now())
}

model publickeycreds {
    id              String   @id @default(auto()) @map("_id") @db.ObjectId
    backed_up       Boolean
    passkey_user_id String   @db.ObjectId
    public_key      Bytes?
    credentialID    String
    transports      String[]
    counter         Int
}

model sessions {
    id      String   @id @map("_id")
    expires DateTime @db.Date
    session Json

    @@index([expires], map: "expires_1")
}

enum SubscriptionTier {
    FREE
    PRO
    ENTERPRISE
}

model UserSubscription {
    id                   String           @id @default(auto()) @map("_id") @db.ObjectId
    user                 User             @relation(fields: [userId], references: [id], onDelete: Cascade)
    userId               String           @unique @db.ObjectId
    tier                 SubscriptionTier @default(FREE)
    periodStart          DateTime         @default(now())
    periodEnd            DateTime?
    generationsUsed      Int              @default(0) // Counter for generations used this period
    generationsQuota     Int              @default(10) // Default free tier quota
    stripeCustomerId     String?
    stripeSubscriptionId String?
    cancelAtPeriodEnd    Boolean          @default(false)
    createdAt            DateTime         @default(now())
    updatedAt            DateTime         @updatedAt
}

type SubscriptionKeys {
    auth   String
    p256dh String
}

model NotificationSubscription {
    id           String           @id @default(auto()) @map("_id") @db.ObjectId
    endpoint     String
    keys         SubscriptionKeys
    userId       String?          @db.ObjectId
    user         User?            @relation(fields: [userId], references: [id], onDelete: Cascade)
    createdAt    DateTime         @default(now())
    expiresAt    DateTime?
    isActive     Boolean          @default(true)
    failureCount Int              @default(0)
    lastSeen     DateTime?
    userAgent    String?
    deviceInfo   Json?

    @@unique([endpoint])
    @@index([userId])
    @@index([expiresAt])
    @@index([isActive])
    @@index([failureCount])
}

model ScheduledNotification {
    id           String    @id @default(auto()) @map("_id") @db.ObjectId
    userId       String    @db.ObjectId
    type         String // 'CARD_DUE', 'STUDY_REMINDER', 'DAILY_REVIEW'
    cardId       String? // For card-specific notifications
    scheduledFor DateTime
    sent         Boolean   @default(false)
    sentAt       DateTime?
    metadata     Json? // Store card count, folder info, etc.
    failureCount Int       @default(0)
    lastError    String?
    createdAt    DateTime  @default(now())
    updatedAt    DateTime  @updatedAt

    user User @relation(fields: [userId], references: [id], onDelete: Cascade)

    @@index([scheduledFor, sent])
    @@index([userId, type])
    @@index([sent, scheduledFor])
    @@index([userId, type, cardId, sent])
    @@map("scheduledNotifications")
}

model UserNotificationPreferences {
    id     String @id @default(auto()) @map("_id") @db.ObjectId
    userId String @unique @db.ObjectId

    // Card due notifications
    cardDueEnabled   Boolean @default(true)
    cardDueTime      String  @default("09:00") // "HH:mm" format
    cardDueThreshold Int     @default(5) // Notify when >= 5 cards due

    // Daily study reminders
    dailyReminderEnabled Boolean @default(false)
    dailyReminderTime    String  @default("19:00")

    // General settings
    timezone          String  @default("UTC")
    quietHoursEnabled Boolean @default(false)
    quietHoursStart   String  @default("22:00")
    quietHoursEnd     String  @default("08:00")

    // Advanced timing
    sendAnytimeOutsideQuietHours Boolean @default(false)
    activeHoursEnabled           Boolean @default(false)
    activeHoursStart             String  @default("09:00")
    activeHoursEnd               String  @default("21:00")

    // Snooze functionality
    snoozedUntil DateTime?

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    user User @relation(fields: [userId], references: [id], onDelete: Cascade)

    @@map("userNotificationPreferences")
}

// =========================
// LLM GATEWAY MODELS
// =========================

model LlmModelRegistry {
    id              String   @id @default(auto()) @map("_id") @db.ObjectId
    modelId         String   @unique // "openai-gpt4o-mini"
    provider        String // "openai", "google", "deepseek"
    modelName       String // "gpt-4o-mini"
    inputCostPer1M  Float // USD per 1M input tokens
    outputCostPer1M Float // USD per 1M output tokens
    capabilities    String[] // ["text", "multimodal"]
    maxTokens       Int? // context window
    latencyBudgetMs Int      @default(500)
    avgLatencyMs    Int? // rolling average
    healthStatus    String   @default("healthy") // "healthy"|"degraded"|"down"
    lastHealthCheck DateTime @default(now())
    priority        Int      @default(5) // 1=highest, 10=lowest
    enabled         Boolean  @default(true)
    createdAt       DateTime @default(now())
    updatedAt       DateTime @updatedAt

    @@index([provider, enabled])
    @@index([priority, healthStatus])
    @@map("llm_model_registry")
}

model LlmGatewayLog {
    id                  String   @id @default(auto()) @map("_id") @db.ObjectId
    userId              String   @db.ObjectId
    user                User     @relation(fields: [userId], references: [id], onDelete: Cascade)
    folderId            String?  @db.ObjectId
    folder              Folder?  @relation(fields: [folderId], references: [id], onDelete: SetNull)
    materialId          String?  @db.ObjectId // Material used for generation
    requestId           String   @unique // UUID for tracing
    selectedModelId     String // from LlmModelRegistry
    provider            String
    task                String // "flashcards", "quiz", "chat"
    inputTokens         Int
    outputTokens        Int
    totalTokens         Int
    inputCostUsdMicros  BigInt
    outputCostUsdMicros BigInt
    totalCostUsdMicros  BigInt
    latencyMs           Int
    cached              Boolean  @default(false)
    cacheHit            Boolean  @default(false)
    status              String // "success"|"error"|"quota_exceeded"|"rate_limited"
    errorCode           String?
    errorMessage        String?
    routingScore        Float? // Score used for model selection
    itemCount           Int? // Adaptive item count for generation
    tokenEstimate       Int? // Estimated tokens for input text
    depth               String? // Generation depth: "quick", "balanced", "deep"
    createdAt           DateTime @default(now())

    @@index([userId, createdAt])
    @@index([selectedModelId, status])
    @@index([task, status])
    @@map("llm_gateway_logs")
}
