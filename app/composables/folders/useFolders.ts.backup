import { z } from "zod";
import { APIError } from "~/services/FetchFactory";

const FolderResponse = z
  .union([FolderSchema, z.object({ data: FolderSchema })])
  .transform((x) => ("id" in x ? x : x.data));
const FoldersResponse = z
  .union([z.array(FolderSchema), z.object({ data: z.array(FolderSchema) })])
  .transform((x) => (Array.isArray(x) ? x : x.data));

// Simplified schema assignments without problematic ZodOut type
const FoldersResponseSchema = FoldersResponse;
const FolderResponseSchema = FolderResponse;

export function useFolders() {
  const { $api } = useNuxtApp();

  const { data, pending, error, refresh } = useDataFetch<Folder[]>(
    "folders",
    () => $api.folders.getFolders(FoldersResponseSchema),
  );
  return {
    folders: data,
    loading: pending,
    error,
    refresh,
  };
}

export function useCreateFolder() {
  const { $api } = useNuxtApp();

  // Use centralized operation handling - all errors constructed by FetchFactory
  const createOperation = useOperation<Folder>();

  const createFolder = async (payload: typeof CreateFolderDTO) => {
    return await createOperation.execute(async () => {
      return await $api.folders.postFolder(payload);
    });
  };

  return {
    createFolder,
    creating: createOperation.pending,
    error: createOperation.error,
    typedError: createOperation.typedError,
  };
}

export const useFolder = (id: string) => {
  const { $api } = useNuxtApp();

  const { data, pending, error, refresh } = useDataFetch<Folder>(
    `folder-${id}`,
    () => $api.folders.getFolder(id, FolderResponseSchema),
  );

  return {
    folder: data,
    loading: pending,
    error,
    refresh,
  };
};

export function useDeleteFolder(id: string) {
  const { $api } = useNuxtApp();

  // Use centralized operation handling - all errors constructed by FetchFactory
  const deleteOperation = useOperation<{ success: boolean }>();

  const deleteFolder = async () => {
    return await deleteOperation.execute(async () => {
      return await $api.folders.deleteFolder(id);
    });
  };

  return {
    deleteFolder,
    deleting: deleteOperation.pending,
    error: deleteOperation.error,
    typedError: deleteOperation.typedError,
    result: deleteOperation.data,
  };
}

export function useUpdateFolder(id: string) {
  const { $api } = useNuxtApp();

  // Use centralized operation handling - all errors constructed by FetchFactory
  const updateOperation = useOperation<Folder>();

  const updateFolder = async (
    payload: typeof UpdateFolderDTO | Record<string, unknown>,
  ) => {
    return await updateOperation.execute(async () => {
      return await $api.folders.updateFolder(id, payload);
    });
  };

  return {
    updateFolder,
    updating: updateOperation.pending,
    error: updateOperation.error,
    typedError: updateOperation.typedError,
  };
}

export function useGenerateFlashcards(
  model: Ref<string | undefined>,
  text: Ref<string | undefined>,
  folderId: Ref<string | undefined>,
) {
  const { $api } = useNuxtApp();
  const flashcards = ref<Array<{ front: string; back: string }>>([]);
  const generating = ref(false);
  const genError = ref<string | null>(null);
  const toast = useToast();

  // Add subscription info
  const {
    subscriptionInfo,
    isQuotaExceeded,
    updateFromData,
    handleApiError,
  } = useSubscription();

  async function generate() {
    genError.value = null;
    flashcards.value = [];

    const t = text.value?.trim();
    const fid = folderId.value;
    console.log("Generating flashcards, text length:", t?.length, "folderId:", fid);
    if (!t) {
      genError.value =
        "This folder has no content yet. Add text or materials, then try again.";
      console.log(genError.value);
      return;
    }

    generating.value = true;
    try {
      // Use GatewayService for proper error handling
      const result = await $api.gateway.generateFlashcards(t, {
        folderId: fid,
        save: !!fid,
        replace: true,
      });
      
      console.log("Flashcard generation response:", result);
      if (result.subscription) {
        updateFromData({ subscription: result.subscription });
      }

      // Show remaining quota toast if low
      if (
        subscriptionInfo.value.tier === "FREE" &&
        subscriptionInfo.value.remaining <= 3
      ) {
        try {
          toast.add({
            title: "Free Tier Limit",
            description: `You have ${subscriptionInfo.value.remaining} generations left in your free quota.`,
          });
        } catch {
          // Ignore toast errors
        }
      }

      // Handle flashcards response
      if (result.task === "flashcards" && result.flashcards) {
        try {
          if (typeof result.savedCount === "number") {
            toast.add({
              title: "Saved",
              description: `Saved ${result.savedCount} flashcards to this folder.`,
            });
          }
        } catch {
          // Ignore toast errors
        }
        flashcards.value = result.flashcards;
      } else {
        genError.value =
          "Server returned unexpected response format.";
      }
    } catch (err) {
      handleApiError(err);
      genError.value = err instanceof APIError ? err.message : "Generation failed. Please try again.";
      flashcards.value = [];
    } finally {
      generating.value = false;
    }
  }

  return {
    flashcards,
    generating,
    genError,
    generate,
    // New subscription-related properties
    subscriptionInfo,
    isQuotaExceeded,
  };
}

export function useGenerateQuiz(
  model: Ref<string | undefined>,
  text: Ref<string | undefined>,
  folderId: Ref<string | undefined>,
) {
  const { $api } = useNuxtApp();
  type Question = { question: string; choices: string[]; answerIndex: number };
  const questions = ref<Question[]>([]);
  const generating = ref(false);
  const genError = ref<APIError | null>(null);
  const toast = useToast();

  // Add subscription info
  const {
    subscriptionInfo,
    isQuotaExceeded,
    updateFromData,
    handleApiError
  } = useSubscription();

  async function generate() {
    genError.value = null;
    questions.value = [];

    const t = text.value?.trim();
    const fid = folderId.value;

    if (!t) {
      genError.value = new APIError(
        "This folder has no content yet. Add text or materials, then try again.",
      );
      return;
    }

    generating.value = true;
    try {
      // Use GatewayService for proper error handling
      const result = await $api.gateway.generateQuiz(t, {
        folderId: fid,
        save: !!fid,
        replace: true,
      });
      
      // Update subscription from response data
      if (result.subscription) {
        updateFromData({ subscription: result.subscription });
      }

      // Show remaining quota toast if low
      if (
        subscriptionInfo.value.tier === "FREE" &&
        subscriptionInfo.value.remaining <= 3
      ) {
        try {
          toast.add({
            title: "Free Tier Limit",
            description: `You have ${subscriptionInfo.value.remaining} generations left in your free quota.`,
          });
        } catch {
          // Ignore toast errors
        }
      }

      // Handle quiz response
      if (result.task === "quiz" && result.quiz) {
        try {
          if (typeof result.savedCount === "number") {
            toast.add({
              title: "Saved",
              description: `Saved ${result.savedCount} questions to this folder.`,
            });
          }
        } catch {
          // Ignore toast errors
        }
        questions.value = result.quiz;
      } else {
        genError.value = new APIError(
          "Server returned unexpected response format.",
        );
      }
    } catch (err) {
      handleApiError(err);
      genError.value = new APIError(
        err instanceof Error ? err.message : "Generation failed.",
      );
      questions.value = [];
    } finally {
      generating.value = false;
    }
  }

  return {
    questions,
    generating,
    genError,
    generate,
    // Subscription-related properties
    subscriptionInfo,
    isQuotaExceeded,
  };
}
            title: "Heads up",
            description:
              "Youâ€™re about to hit the rate limit. Try again in a minute.",
          });
        } catch {
          // Ignore toast errors
        }
      }
      const data = resp._data ?? resp;
      const parsed = LLMGenerateResponse.parse(data);
      if (parsed.task === "quiz") {
        try {
          if (typeof parsed.savedCount === "number") {
            toast.add({
              title: "Saved",
              description: `Saved ${parsed.savedCount} questions to this folder.`,
            });
          }
        } catch {
          // Ignore toast errors
        }
        questions.value = parsed.quiz;
      } else {
        genError.value = new APIError(
          "Server returned a flashcards payload when quiz was requested.",
        );
      }
    } catch (err) {
      genError.value = new APIError(
        err instanceof Error ? err.message : "Generation failed.",
      );
      questions.value = [];
    } finally {
      generating.value = false;
    }
  }

  return {
    questions,
    generating,
    genError,
    generate,
    rateLimitRemaining,
    rateLimitRemainingUser,
    rateLimitRemainingIP,
  };
}
